= PureBasic et la Programmation Orientée Objet
Dräc
v0.3, November 27, 2016: WIP Porting from HTML.
:title: PureBasic et la Programmation Orientée Objet — ou «la POO démystifiée»
:doctype: article
:encoding: utf-8
:lang: fr
:toc: left
:sectnums:
:highlightjsdir: ../hjs
:idprefix:
:idseparator: -
:icons: font
:version-label: Draft

////
==============================================================================
                                    TODOs
==============================================================================
-- Understand better punctuation marks ruls in French:
    -- use of space (or "thin space") before double pointed marks (?!:; %)
       and between a word and its surrounding quotes.
    -- Should I use “…” or «…» ?
    -- How to render "thin space" (&#8201;) in AsciiDoc?
////

.About This Tutorial
****
**CREDITS**: This is a reprint of «Dräc»’s multi-part tutorial __PureBasic et la Programmation Orientée Objet__, also knwon as __la POO démystifiée__, published in 2005  on http://drac.site.chez-alice.fr/Tutorials%20Programming%20PureBasic/POO/POO_Pourquoi.htm[drac.site.chez-alice.fr].

**LICENSE**: It was reprinted with explicit permission of the author, who released the tutorial text and source codes under https://creativecommons.org/licenses/by/4.0/deed.fr[Creative Commons Attribution]  (CC BY 4.0) in response to the permission request to reproduce it inside the https://github.com/tajmone/purebasic-archives[PureBASIC Archives].

**CHANGES**: The tutorial was ported from HTML to AsciiDoc by https://github.com/tajmone[Tristano Ajmone], who also made minor changes to code examples (either aesthetic, or minor corrections, or to ensure compatibility with latest version of PureBASIC).

First republished: 2016/11/?? — by https://github.com/tajmone[@tajmone].
****

// Website Page 1

== Pourquoi de la POO en PureBasic ?

Il peut sembler surprenant de chercher à réaliser en PureBasic, qui est un langage procédural, une représentation orientée objet, d’autant que de nombreux langages adaptés à la POO existent.

Mais que certains langages de programmation soient « Objets » et que d’autres ne le soient pas, traduit uniquement l’existence de mots-clés supplémentaires qui facilitent l’écriture de ces programmes.
Ainsi, les langages orientés-objets enrichissent la sémantique mais ne modifient en rien l’aspects de la compilation par rapport à un langage non-Objet. Ils ne font que rajouter une couche au-dessus de ce dernier.

On peut donc tout à fait en implémenter les concepts en PureBasic au prix d’une certaine rigueur de développement et de notation. C’est là que se situe l’avantage immédiat des langages Objets.

Néanmoins, la mise en œuvre de la méthode objet en PureBasic offre, outre la possibilité de programmer selon cette philosophie, l’intérêt de dévoiler certains mécanismes sous-jacents des mots-clés des langages objets.

Cet article présente une technique de programmation permettant à des projets PureBasic d’envergure de bénéficer d’une conception orienté objet. Il est entendu qu’il ne s’agit pas ici d’un cours des techniques POO et que le lecteur possède une bonne connaissance du langage PureBasic.


// Website Page 2

== Les concepts objets

La Programmation Orientée Objet introduit des concepts comme l’objet, l’héritage ou le polymorphisme.
Nous allons essayer de voir comment les principaux concepts peuvent être réalisés en PureBasic.
Mais avant cela, il nous faut définir ces concepts.

=== La notion d’objet

Un objet possède un état interne:

*   L’état est représenté par la valeur de chacun de ses composants à un instant donné,
*   Un composant est soit une valeur, soit un autre objet.

Il utilise et met à disposition des services :

*   Il interagit avec l’extérieur par l’intermédiaire de fonctions appelées méthodes

Il est unique (notion d’identité)

Un objet peut être vue de deux façons :

*   De part les services qu’il rend : vue externe (spécification). C’est le côté utilisateur,
*   De part la manière dont sont implémentés, en son sein, les services : vue interne (implémentation). C’est le côté développeur.

Du point de vu du développeur, l’objet est donc une zone mémoire contiguë contenant des informations : des variables appelées **attributs** et des fonctions appelées **méthodes**.
Le fait que l’on appelle les fonctions d’un objet des méthodes, tient au fait qu’elles sont propres à l’objet et permettent la manipulation des attributs de cet objet.

=== La notion de Classe

Il s’agit d’une extension de la notion de type que l’on trouve en PureBasic.

Dans un contexte donné, plusieurs objets peuvent posséder la même structure et le même comportement.
On les regroupe alors dans une même " Classe ".

Du point de vu du développeur, la Classe définit ce que contient un objet de cette classe : la nature de ses attributs (type de chaque variable) et ses méthodes (noms, implémentations).

Si le type d’une variable est un entier, le type d’un objet est sa Classe.

=== La notion d’instance

*   Une instance est un objet défini à partir d’une classe.
*   Un tel processus s’appelle l’instanciation.
*   Cela correspond à la déclaration de variables dans PureBasic.
*   L’objet est **normalement initialisé** dès sa création.

=== L’encapsulation

En théorie, on ne devrait pouvoir manipuler les attributs d’un objet qu’en passant par les méthodes. Cette technique, qui permet de ne rendre visible à l’utilisateur qu’une partie de l’objet, est appelée encapsulation.

L’encapsulation a comme avantage de garantir l’intégrité des attributs. En effet, c’est le développeur qui, par l’intermédiaire des méthodes mises à la disposition de l’utilisateur, maîtrise les modifications apportées à l’objet.

C’est du moins, à notre niveau ce que l’on en retiendra.

=== L’héritage

L’héritage permet de définir de nouvelles Classes en utilisant des Classes déjà existantes.

Du point de vue du développeur, cela revient à pouvoir ajouter des attributs et des méthodes à ceux existants dans une Classe pour en définir une autre, voir même à **modifier** certaines méthodes.

Il existe deux types d’héritages :

*   L’héritage simple : La nouvelle Classe est définie à partir d’une seule Classe existante
*   L’héritage multiple : La nouvelle Classe est définie à partir de plusieurs Classes existantes

Bien que possible à programmer, l’héritage multiple est complexe à mettre en œuvre et ne sera pas abordé ici.

Nous nous limiterons à l’héritage simple.

[big]##**Terminologie:**##

*   La Classe qui hérite d’une autre Classe, est souvent appelée Classe Fille
*   La Classe qui donne son héritage à une Classe Fille est souvent appelée Classe Mère.

=== La surcharge

On dit qu’une méthode est surchargée, si elle réalise des actions différentes selon la nature des objets visés.

Prenons un exemple :

Les objets suivants: cercle, rectangle et triangle sont des formes géométriques.
On peut définir pour ces objets une même Classe qu’on appellera Forme.
Les objets sont donc des instances de la classe Forme.

Si on veut afficher les objets, il faut que la classe Forme dispose d’une méthode " Dessiner ".

Ainsi doté, chaque objet dispose donc d’une méthode " Dessiner " pour s’afficher. Or, cette méthode ne peut-être la même selon que l’on veut afficher un cercle ou un rectangle.

Les objets d’une même Classe utilisent donc la même méthode " Dessiner ", mais la nature de l’objet (Rectangle, Triangle) spécifie l’implémentation de la méthode.

On dit que la méthode Dessiner est surchargée: du point de vu de l’utilisateur afficher un cercle ou un rectangle se fait de la même manière, ceci en toute transparence.

Du point de vue du développeur, l’implémentation des méthodes diffère.

Au lieu de méthode surchargée, on peut parler aussi de méthode polymorphe (ayant plusieurs formes).

=== Notion de Classe abstraite

Nous avons vu qu’une Classe regroupe la définition des attributs d’un objet ainsi que ces méthodes.
Supposons que l’on ne puisse pas donner l’implémentation d’une des méthodes de la Classe. La méthode n’est qu’un nom sans code. On parle alors de méthode abstraite.
Une Classe comportant au moins une méthode abstraite est qualifiée de Classe abstraite.

On peut se demander la raison d’être d’une classe abstraite puisque l’on ne peut créer d’objet d’une telle Classe. Les Classes abstraites permettent de définir des <<La notion de Classe,Classes d’objets>> qualifiées par opposition de concrètes. Le passage de l’une à l’autre se fait par héritage en prenant le soin de donner les implémentations nécessaires aux méthodes abstraites.

Les Classes abstraites ont donc un rôle d’interface, car qu’elles décrivent la spécification générique de toutes les Classes qui en hérite.

// Website Page 3

== Première Implémentation

Dans ce qui va suivre, nous allons voir comment les concepts objets qui viennent d’être abordés peuvent être implémentés en PureBasic.
En aucun cas cela fait référence à ce qui est programmé dans les langages objets. De plus, le propre de l’implémentation c’est de pouvoir être amélioré ou de s’adapter au besoin.
Nous proposons donc ici une de ces d’implémentations avec ses avantages et ses limites.

=== Classe concrète et Classe abstraite

Comme nous l’avons vu, la Classe définie ce que contient un objet:

*   ses attributs (type de chaque variable)
*   ses méthodes (noms, implémentation)

Si, par exemple, on veut représenter des objets Rectangle et les afficher à l’écran, on définira donc une Classe `Rectangle` possédant une méthode ``Dessiner()``.

La Classe `Rectangle` pourrait avoir la construction suivante:

// CODE CHECKED!

// Example N. 3.1-1
[source,purebasic]
---------------------------------------------------------------------
Structure Rectangle
  *Dessiner
  x1.l
  x2.l
  y1.l
  y2.l
EndStructure

Procedure Dessiner_Rectangle(*this.Rectangle)
  ; [ ...some code... ]
EndProcedure
---------------------------------------------------------------------

où ``x1``, ``x2``, `y1` et `y2` sont quatre attributs (les coordonnées des points diamétralement opposés du rectangle) et `*Dessiner` est un pointeur faisant référence à la fonction de dessin qui affiche les Rectangles.
`*Dessiner` est ici un pointeur de fonction utilisé pour contenir l’adresse de la fonction désirée : ``@Dessiner_Rectangle()``.
Il suffit d’utiliser `CallFunctionFast()` pour lancer l’exécution de la fonction ainsi référencée.

Nous voyons donc que l’instruction Structure est tout à fait adaptée à la notion de Classe:
*   Nous y trouvons la définition des attributs d’un objet : ici ``x1``, ``x2``, `y1` et `y2` sont de type entier Long.
*   Nous y trouvons la définition des méthodes : ici `Dessiner()` grâce à un pointeur de fonction.

Si la Classe ainsi définie est suivit de l’implémentation des méthodes (dans notre exemple il s’agit de la déclaration du bloc Procedire/EndProcedure de ``Dessiner_Rectangle()``), la Classe sera une Classe concrète.
Dans le cas contraire elle sera abstraite.

[IMPORTANT]
====
On appelle toujours ``*this``, le pointeur vers l’objet auquel on applique la méthode. Cette notation est appliquée dans notre exemple avec la méthode ``Dessiner_Rectangle()``.
====

=== Instanciation

Si l’on désire créer maintenant un objet `Rect1` issu de la classe ``Rectangle``, cela revient à écrire :

// CODE CHECKED!

// Example N. 3.2-1
[source,purebasic]
---------------------------------------------------------------------
Rect1.Rectangle
---------------------------------------------------------------------

Pour l’initialiser, il suffit d’écrire :

// CODE CHECKED!

// Example N. 3.2-2
[source,purebasic]
---------------------------------------------------------------------
Rect1\Dessiner = @Dessiner_Rectangle()
Rect1\x1 = 0
Rect1\x2 = 10
Rect1\y1 = 0
Rect1\y2 = 20
---------------------------------------------------------------------

Par la suite, pour dessiner l’objet ``Rect1``, on écrira:

// CODE CHECKED!

// Example N. 3.2-3
[source,purebasic]
---------------------------------------------------------------------
CallFunctionFast(Rect1\Dessiner, @Rect1)
---------------------------------------------------------------------

=== Encapsulation

Dans cette implémentation, l’encapsulation n’existe pas, tout simplement car il n’y a pas moyen de cacher les attributs ou les méthodes d’un tel objet.

En effet, il suffit d’écrire `Rect1\x1` pour accéder à l’attribut `x1` de l’objet. C’est d’ailleurs ce moyen que nous avons utilisé pour initialiser l’objet.
Nous verrons dans la deuxième implémentation, comment cela peut changer.
Cependant, cette notion, bien qu’important, n’est pas la plus essentielle pour faire de la POO.

=== Héritage

Imaginons maintenant que l’on souhaite créer une nouvelle Classe d’objet `Rectangle` capable en plus de s’effacer de l’écran.
On peut se servir de la Classe existante `Rectangle` et y adjoindre la nouvelle méthode `Effacer()` pour créer la nouvelle Classe ``Rectangle2``.

Une Classe étant une ``Structure``, nous allons profiter de la propriété qu’a une structure d’être étendue. Ainsi, la nouvelle Classe `Rectangle2` peut s’écrire :

// CODE CHECKED!

// Example N. 3.4-1
[source,purebasic]
---------------------------------------------------------------------
Structure Rectangle2 Extends Rectangle
  *Effacer
EndStructure

Procedure Effacer_Rectangle(*this.Rectangle2)
  ; [ ...some code... ]
EndProcedure
---------------------------------------------------------------------

La Classe Rectangle2 possède donc bien les membres de la Classe `Rectangle` et une nouvelle méthode ``Effacer()``.
En effet, l’instanciation d’un objet de cette Classe donne :

// CODE CHECKED!

// Example N. 3.4-2
[source,purebasic]
---------------------------------------------------------------------
Rect2.Rectangle2

Rect2\Dessiner = @Dessiner_Rectangle()
Rect2\Effacer = @Effacer_Rectangle()
Rect2\x1 = 0
Rect2\x2 = 10
Rect2\y1 = 0
Rect2\y2 = 20
---------------------------------------------------------------------

Pour utiliser les méthodes Dessiner() et Effacer() de Rect2, on procèdera de la même manière que précédemment.

Nous pouvons donc dire que Rectangle2 a hérité des propriétés de la Classe Rectangle.

[NOTE]
====
L’héritage est une forme de polymorphisme. L’objet `Rect2` peut etre vu comme un Objet de la Classe ``Rectangle``, il suffit de ne pas se servir de la méthode ``Effacer()``. Par héritage, l’objet revête donc plusieurs formes : celles des objets issus des différentes Classes Mères. On parle alors de polymorphisme d’héritage.
====

=== Surcharge

Lors de l’initialisation d’un objet, on initialise les pointeurs de fonction en leur affectant l’adresse de la méthode qui convient à l’objet.

Ainsi, pour un objet Rect de Classe ``Rectangle``, en écrivant:

// CODE CHECKED!

// Example N. 3.5-1
[source,purebasic]
---------------------------------------------------------------------
Rect1\Dessiner = @Dessiner_Rectangle()
---------------------------------------------------------------------

on peut utiliser la méthode `Dessiner()` comme suite:

// CODE CHECKED!

// Example N. 3.5-2
[source,purebasic]
---------------------------------------------------------------------
CallFunctionFast(Rect1\Dessiner, @Rect1)
---------------------------------------------------------------------

Maintenant, imaginons qu’il soit possible d’implémenter une autre méthode pour l’affichage d’un rectangle (utilisant un algorithme distinct de celui de la premiere méthode).

Appelons la ``Dessiner_Rectangle2()``:

// CODE CHECKED!

// Example N. 3.5-3
[source,purebasic]
---------------------------------------------------------------------
Procedure Dessiner_Rectangle2(*this.Rectangle)
  ; [ ...some code... ]
EndProcedure
---------------------------------------------------------------------

Il est tout à fait possible d’initialiser notre objet Rect1 avec cette nouvelle méthode sans grande peine:

// CODE CHECKED!

// Example N. 3.5-4
[source,purebasic]
---------------------------------------------------------------------
Rect1\Dessiner = @Dessiner_Rectangle2()
---------------------------------------------------------------------

Si l’on veut utiliser la méthode on écrira à nouveau:

// CODE CHECKED!

// Example N. 3.5-5
[source,purebasic]
---------------------------------------------------------------------
CallFunctionFast(Rect1\Dessiner, @Rect1)
---------------------------------------------------------------------

Nous constatons bien que dans un cas (méthode ``Dessiner_Rectangle()``) comme dans l’autre (méthode ``Dessiner_Rectangle2()``) l’utilisation de la méthode de l’objet `Rect1` est strictement identique.
Il ne nous est pas possible en effet par la seule ligne "``CallFunctionFast(Rect1\Dessiner, @Rect1)``"  de distinguer la méthode `Dessiner()` que l’objet `Rect1` utilise.
Pour y arriver, il faut remonter jusqu’à l’initialisation de l’objet.

La notion de pointeur de fonction permet donc la surcharge de la méthode `Dessiner()` de la Classe ``Rectangle``.

Il y a tout de même une limitation dans cette surcharge. L’utilisation de l’instruction `CallFunctionFast()` implique de faire attention au nombre de paramètres.

=== Conclusion :

Dans cette première implémentation, nous disposons d’un objet capable de répondre aux principaux concepts orientés objet avec certaines limitations.
Nous venons surtout de poser les bases qui vont nous servir à réaliser un objet plus complet, ceci grâce à l’instruction `Interface` de PureBasic.

== L’instruction Interface

// CODE CHECKED!

// Example N. 4-1
.Syntaxe :
[source,purebasic pseudocode]
---------------------------------------------------------------------
Interface <Nom1> [Extends <Nom2>]
  [Procedure1]
  [Procedure2]
  ...
EndInterface
---------------------------------------------------------------------

L’instruction `Interface` de PureBasic, permet de regrouper sous un même Nom (``<Nom1>`` dans l’encadré) différentes procédures.

Ex :

// CODE CHECKED!

// Example N. 4-2

[source,purebasic]
---------------------------------------------------------------------
Interface Mon_Objet
  Procedure1(x1.l, y1.l)
  Procedure2(x2.l, y2.l)
EndInterface
---------------------------------------------------------------------

Il suffit de déclarer un élément de type `Mon_Objet` pour accéder aux procédures qu’elle détient.
La déclaration se fait de la même manière que pour une `Structure` :

// Example N. 4-3

[source,purebasic]
---------------------------------------------------------------------
Objet.Mon_Objet
---------------------------------------------------------------------

Nous pouvons alors utiliser les fonctions de Objet directement comme suite:

// CODE CHECKED!

// Example N. 4-4

[source,purebasic]
---------------------------------------------------------------------
Objet\Procedure1(10, 20)
Objet\Procedure2(30, 40)
---------------------------------------------------------------------

Lancer une procedure grâce à l’instruction Interface se fait par une notation fort pratique et agréable.
En écrivant " Objet\Procedure1(10, 20) ", on lance la Procedure1() de l’élément Objet.
Cette notation est typique de la Programmation Orienté Objet.

==== Initialisation :

Comme toute déclaration d’une variable typée, il s’en suit normalement l’initialisation de la variable.
Il en est de même lorsque l’on déclare un élément dont le type provient d’une ``Interface``.

Contre toute attente, il ne suffit pas de donner le nom d’une procédure à l’intérieur du bloc `Interface : EndInterface` pour que cela fasse référence à l’implémentation de cette procédure, c’est à dire que l’on référence le bloc `Procédure : EndProcedure` de la procédure voulue.

En réalité vous pouvez renommer les procédures dans un bloc ``Interface : EndInterface``, c’est à dire donner les noms que vous voulez aux procédures que vous allez utiliser.

Comment relier alors ce nouveau nom à la vraie procédure ?

Comme pour la surcharge de méthode, la solution se trouve dans les adresses de fonctions.
Il faut voir en effet les noms contenus dans le bloc Interface/EndInterface, comme des pointeurs de fonctions auxquels on attribut les adresses des fonctions que l’on désire y mettre.

Cependant, pour initialiser les pointeurs de fonctions d’un élément typé par une ``Interface``, il faut procéder différemment qu’avec un élément typé par une ``Structure``.
Il n’est en effet pas possible d’initialiser individuellement chacun des champs définis par une Interface, car rappelez-vous que d’écrire `Objet\Procedure1()` revient à lancer une procédure.

L’initialisation se réalise indirectement en donnant à l’élément l’adresse d’une variable composée des pointeurs de fonctions préalablement initialisée.

Une telle variable est appelée table des méthods.

Ex : Si l’on reprend l’``Interface Mon_Objet``.
Considérons la `Structure` suivante de description des pointeurs de fonctions :

// CODE CHECKED!

// Example N. 4.1-1
[source,purebasic]
---------------------------------------------------------------------
Structure Mes_Methodes
  *Procedure1
  *Procedure2
EndStructure
---------------------------------------------------------------------

et la variable initialisée associée:

// CODE CHECKED!

// Example N. 4.1-2
[source,purebasic]
---------------------------------------------------------------------
Methodes.Mes_Methodes
Methodes\Procedure1 = @Ma_Procedure1()
Methodes\Procedure2 = @Ma_Procedure2()
---------------------------------------------------------------------

où `Ma_Procedure1()` et `Ma_Procedure2()` sont les implémentations des procédures que l’on veut utiliser.

Alors, l’initialisation de l’élément `Objet` de type `Mon_Objet` se fera comme suite :

// CODE CHECKED!

// Example N. 4.1-3
[source,purebasic]
---------------------------------------------------------------------
Objet.Mon_Objet = @Methodes
---------------------------------------------------------------------

Ainsi, en écrivant

// CODE CHECKED!

// Example N. 4.1-4
[source,purebasic]
---------------------------------------------------------------------
Objet\Procedure2(30, 40)
---------------------------------------------------------------------

on lance la fonction `Procedure2()` de l’élément ``Objet``, c’est à dire ``Ma_Procedure2()``.

[IMPORTANT]
====
Lorsque l’on déclare un élément typé par une interface, il est obligatoire de l’initialiser avant de se servir des procédures de l’élément. Il est donc vivement conseillé d’initialiser l’élément dès sa déclaration.
====

[IMPORTANT]
====
La composition de la Structure décrivant les pointeurs de fonctions, doit être le reflet exact de la composition de l’``Interface``. C’est à dire qu’elle doit comporter le même nombre de champs et respecter l’ordre pour que l’attribution entre les noms et les adresses de chaque fonction soit celle attendue. C’est seulement à ces conditions que l’élément sera correctement initialisé.
====

Pour résumer, utiliser une Interface c’est disposer:

*   d’une `Interface` décrivant les procédures que l’on veut utiliser,
*   d’une `Structure` décrivant les pointeurs d’adresses des fonctions,
*   d’une **table des méthodes**: variable initialisée issue de cette structure.

C’est aussi:

*   bénéficier d’une notation orientée objet,
*   pouvoir renommer facilement les procédures.

// ============== REVISED UP TO THIS POINT! ==============

// Website Page 5

